<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" mouseUp="mouseUpHdlr(event)" mouseDown="mouseDownHdlr(event)" mouseMove="mouseMoveHdlr(event)">
	<mx:Script>
		<![CDATA[
			import mx.containers.VBox;
			import mx.containers.Panel;
			public var nid:int;
			public var nodeType:String;
			public var inputFromNodes:Dictionary = new Dictionary();
			public var outputToNodes:Dictionary = new Dictionary();
			public var parentCont:EditTM;
			protected var m_inputCenter:Point;
			protected var m_outputCenter:Point;
			private var dragging:Boolean = false;
			[Bindable]
			public var propsContainer:propsBase;
			public function get inputCenter():Point
			{
				return parentCont.ecran.globalToLocal(localToGlobal(m_inputCenter))
			}
			public function get outputCenter():Point
			{
				return parentCont.ecran.globalToLocal(localToGlobal(m_outputCenter));
			}
			public function getXmlRepresentation():XMLNode
			{ return null }
			// update the propsContainer
			public function activateProps():void
			{
				this.parentCont.propertiesPanel.removeAllChildren();
				this.parentCont.propertiesPanel.addChild(this.propsContainer);
			}
			private function mouseDownHdlr(event:MouseEvent):void
			{
				event.stopImmediatePropagation();
				if (event.shiftKey || event.ctrlKey || event.altKey) // set the start node for the operation
					this.parentCont.activeNode = this;
				else									 // start dragging
				{
					startDrag();
					dragging = true;
					activateProps();
				}
			}
			private function mouseUpHdlr(event:MouseEvent):void
			{
				if (dragging)		// drag the node
				{
					stopDrag();
					dragging = false;
				}
				if (event.shiftKey)		// delete the node
				{
					if (this.parentCont.activeNode == this)
					{
						// remove references
						for each (var ref:int in this.inputFromNodes)
							delete PackNodeBase(this.parentCont.nodesMap[ref]).outputToNodes[this.nid];
						for each (var ref2:int in this.outputToNodes)
							delete PackNodeBase(this.parentCont.nodesMap[ref2]).inputFromNodes[this.nid];
						// remove from stage
						delete this.parentCont.nodesMap[this.nid];
						this.parentCont.reDrawConnections();
						this.parentCont.ecran.removeChild(this);
					}
				}
				else if (event.ctrlKey) // add new connection
				{
					if (this.parentCont.activeNode != null && this.parentCont.activeNode != this)
					{
						this.parentCont.activeNode.outputToNodes[this.nid] = this.nid;
						this.inputFromNodes[this.parentCont.activeNode.nid] = this.parentCont.activeNode.nid;
						this.parentCont.reDrawConnections();
					}
				}
				else if (event.altKey)	// delete the connection
				{
					if (this.parentCont.activeNode != null && this.parentCont.activeNode != this)
					{
						delete this.parentCont.activeNode.outputToNodes[this.nid];
						delete this.inputFromNodes[this.parentCont.activeNode.nid];
						this.parentCont.reDrawConnections();
					}
				}
			}
			private function mouseMoveHdlr(event:MouseEvent):void
			{
				if (dragging)
				{
					parentCont.reDrawConnections();
					this.propsContainer.showPos(this.x, this.y);
				}
			}
		]]>
	</mx:Script>

</mx:Canvas>
